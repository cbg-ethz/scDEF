{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Deep exponential families for single-cell data. scDEF learns hierarchies of cell states and their gene signatures from scRNA-seq data. The method can be used for dimensionality reduction, visualization, gene signature identification, clustering at multiple levels of resolution, and batch integration. The informed version (iscDEF) can additionally take known gene lists to jointly assign cells to types and find clusters within each type.</p>"},{"location":"#installation","title":"Installation","text":"<p>scDEF is available through PyPI:</p> <pre><code>pip install scdef\n</code></pre> <p>Please be sure to install a version of JAX that is compatible with your GPU (if applicable). scDEF is much faster on the GPU than on the CPU.</p>"},{"location":"#optional-using-the-scdefbenchmark-module","title":"Optional: using the <code>scdef.benchmark</code> module","text":"<p>The <code>scdef.benchmark</code> module includes wrapper functions to other methods. If you wish to use it, please install the extras:</p> <pre><code>pip install scdef[extras]\n</code></pre> <p>The <code>scdef.benchmark</code> also contains a wrapper function to <code>scVI</code> from scvi-tools, but <code>scvi-tools</code> is not included in the extras and it must be installed separately if you wish to use it. The same applies to scHPF.</p>"},{"location":"#example-notebooks","title":"Example notebooks","text":"<p>To get started with scDEF, please see the example notebooks:</p> <ul> <li> <p>Introduction to scDEF on 3k PBMCs</p> </li> <li> <p>Identifying cell type hierarchies in a whole adult animal</p> </li> <li> <p>Integration of two batches of PBMCs</p> </li> <li> <p>Identifying signatures of interferon-response in PBMCs</p> </li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>Pedro Fal\u00e9 Ferreira @pedrofale</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#model-classes","title":"Model classes","text":""},{"location":"api/#scdef.scDEF","title":"<code>scdef.scDEF</code>","text":"<p>             Bases: <code>object</code></p> <p>Single-cell Deep Exponential Families model.</p> <p>This model learns multi-level gene signatures describing the input scRNA-seq data from an AnnData object.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object containing the gene expression data. scDEF learns a model from counts, so they must be present in either adata.X or in adata.layers.</p> required <code>counts_layer</code> <code>Optional[str]</code> <p>layer from adata.layers to get the count data from.</p> <code>None</code> <code>layer_sizes</code> <code>Optional[list]</code> <p>number of factors per scDEF layer.</p> <code>[100, 60, 30, 10, 1]</code> <code>batch_key</code> <code>Optional[str]</code> <p>key in adata.obs containing batch annotations for batch correction. If None, or not found, no batch correction is performed.</p> <code>'batch'</code> <code>seed</code> <code>Optional[int]</code> <p>random seed for JAX</p> <code>1</code> <code>logginglevel</code> <code>Optional[int]</code> <p>verbosity level for logger</p> <code>INFO</code> <code>layer_shapes</code> <code>Optional[list]</code> <p>prior parameters for the z shape to use in each scDEF layer</p> <code>None</code> <code>brd_strength</code> <code>Optional[float]</code> <p>BRD prior concentration parameter</p> <code>1000.0</code> <code>brd_mean</code> <code>Optional[float]</code> <p>BRD prior mean parameter</p> <code>0.01</code> <code>use_brd</code> <code>Optional[bool]</code> <p>whether to use the BRD prior for factor relevance estimation</p> <code>True</code> <code>cell_scale_shape</code> <code>Optional[float]</code> <p>concentration level in the cell scale prior</p> <code>1.0</code> <code>gene_scale_shape</code> <code>Optional[float]</code> <p>concentration level in the gene scale prior</p> <code>1.0</code> <code>factor_shapes</code> <code>Optional[list]</code> <p>prior parameters for the W shape to use in each scDEF layer</p> <code>None</code> <code>factor_rates</code> <code>Optional[list]</code> <p>prior parameters for the W rate to use in each scDEF layer</p> <code>None</code> <code>layer_diagonals</code> <code>Optional[list]</code> <p>prior diagonal strengths for the W parameters in each scDEF layer</p> <code>None</code> <code>batch_cpal</code> <code>Optional[str]</code> <p>default color palette for batch annotations</p> <code>'Dark2'</code> <code>layer_cpal</code> <code>Optional[list]</code> <p>default color palettes for scDEF layers</p> <code>None</code> <code>lightness_mult</code> <code>Optional[float]</code> <p>multiplier to define lightness of color palette at each scDEF layer</p> <code>0.15</code>"},{"location":"api/#scdef.scDEF.filter_factors","title":"<code>filter_factors(thres=None, iqr_mult=0.0, min_cells=0.005, filter_up=True)</code>","text":"<p>Filter our irrelevant factors based on the BRD posterior or the cell attachments.</p> <p>Parameters:</p> Name Type Description Default <code>thres</code> <code>Optional[float]</code> <p>minimum factor BRD value</p> <code>None</code> <code>iqr_mult</code> <code>Optional[float]</code> <p>multiplier of the difference between the third quartile and the median BRD values to set the threshold</p> <code>0.0</code> <code>min_cells</code> <code>Optional[float]</code> <p>minimum number of cells that each factor must have attached to it for it to be kept. If between 0 and 1, fraction. Otherwise, absolute value</p> <code>0.005</code> <code>filter_up</code> <code>Optional[bool]</code> <p>whether to remove factors in upper layers via inter-layer attachments</p> <code>True</code>"},{"location":"api/#scdef.scDEF.get_hierarchy","title":"<code>get_hierarchy(simplified=True)</code>","text":"<p>Get a dictionary containing the polytree contained in the scDEF graph.</p> <p>Parameters:</p> Name Type Description Default <code>simplified</code> <code>Optional[bool]</code> <p>whether to collapse single-child nodes</p> <code>True</code> <p>Returns:</p> Name Type Description <code>hierarchy</code> <code>Mapping[str, Sequence[str]]</code> <p>the dictionary containing the hierarchy</p>"},{"location":"api/#scdef.scDEF.learn","title":"<code>learn(n_epoch=[1000, 1000], lr=0.1, annealing=1.0, num_samples=10, batch_size=None, layerwise=False)</code>","text":"<p>Fit a variational approximation to the posterior over scDEF parameters.</p> <p>Parameters:</p> Name Type Description Default <code>n_epoch</code> <code>Optional[Union[int, list]]</code> <p>number of epochs (full passes of the data). Can be a list of ints for multi-step learning.</p> <code>[1000, 1000]</code> <code>lr</code> <code>Optional[Union[float, list]]</code> <p>learning rate. Can be a list of floats for multi-step learning.</p> <code>0.1</code> <code>annealing</code> <code>Optional[Union[float, list]]</code> <p>scale factor for the entropy term. Can be a list of floats for multi-step learning.</p> <code>1.0</code> <code>num_samples</code> <code>Optional[int]</code> <p>number of Monte Carlo samples to use in the ELBO approximation.</p> <code>10</code> <code>batch_size</code> <code>Optional[int]</code> <p>number of data points to use per iteration. If None, uses all. Useful for data sets that do not fit in GPU memory.</p> <code>None</code> <code>layerwise</code> <code>Optional[bool]</code> <p>whether to optimize the model parameters in a step-wise manner: first learn only Layer 0 and 1, and then 2, and then 3, and so on. The size of the n_epoch or lr schedules will be ignored, only the first value will be used and each step will use that n_epoch value.</p> <code>False</code>"},{"location":"api/#scdef.scDEF.make_graph","title":"<code>make_graph(hierarchy=None, show_all=False, factor_annotations=None, top_factor=None, show_signatures=True, enrichments=None, top_genes=None, show_batch_counts=False, filled=None, wedged=None, color_edges=True, show_confidences=False, mc_samples=100, n_cells_label=False, n_cells=False, node_size_max=2.0, node_size_min=0.05, scale_level=False, show_label=True, gene_score=None, gene_cmap='viridis', **fontsize_kwargs)</code>","text":"<p>Make Graphviz-formatted scDEF graph.</p> <p>Parameters:</p> Name Type Description Default <code>hierarchy</code> <code>Optional[dict]</code> <p>a dictionary containing the polytree to draw instead of the whole graph</p> <code>None</code> <code>show_all</code> <code>Optional[bool]</code> <p>whether to show all factors even post filtering</p> <code>False</code> <code>factor_annotations</code> <code>Optional[dict]</code> <p>factor annotations to include in the node labels</p> <code>None</code> <code>top_factor</code> <code>Optional[str]</code> <p>only include factors below this factor</p> <code>None</code> <code>show_signatures</code> <code>Optional[bool]</code> <p>whether to show the ranked gene signatures in the node labels</p> <code>True</code> <code>enrichments</code> <code>Optional[DataFrame]</code> <p>enrichment results from gseapy to include in the node labels</p> <code>None</code> <code>top_genes</code> <code>Optional[int]</code> <p>number of genes from each signature to be shown in the node labels</p> <code>None</code> <code>show_batch_counts</code> <code>Optional[bool]</code> <p>whether to show the number of cells from each batch that attach to each factor</p> <code>False</code> <code>filled</code> <code>Optional[str]</code> <p>key from self.adata.obs to use to fill the nodes with</p> <code>None</code> <code>wedged</code> <code>Optional[str]</code> <p>key from self.adata.obs to use to wedge the nodes with</p> <code>None</code> <code>color_edges</code> <code>Optional[bool]</code> <p>whether to color the graph edges according to the upper factors</p> <code>True</code> <code>show_confidences</code> <code>Optional[bool]</code> <p>whether to show the confidence score for each signature</p> <code>False</code> <code>mc_samples</code> <code>Optional[int]</code> <p>number of Monte Carlo samples to take from the posterior to compute signature confidences</p> <code>100</code> <code>n_cells_label</code> <code>Optional[bool]</code> <p>wether to show the number of cells that attach to the factor</p> <code>False</code> <code>n_cells</code> <code>Optional[bool]</code> <p>wether to scale the node sizes by the number of cells that attach to the factor</p> <code>False</code> <code>node_size_max</code> <code>Optional[int]</code> <p>maximum node size when scaled by cell numbers</p> <code>2.0</code> <code>node_size_min</code> <code>Optional[int]</code> <p>minimum node size when scaled by cell numbers</p> <code>0.05</code> <code>scale_level</code> <code>Optional[bool]</code> <p>wether to scale node sizes per level instead of across all levels</p> <code>False</code> <code>show_label</code> <code>Optional[bool]</code> <p>wether to show labels on nodes</p> <code>True</code> <code>gene_score</code> <code>Optional[str]</code> <p>color the nodes by the score they attribute to a gene, normalized by layer. Overrides filled and wedged</p> <code>None</code> <code>gene_cmap</code> <code>Optional[str]</code> <p>colormap to use for gene_score</p> <code>'viridis'</code> <code>**fontsize_kwargs</code> <p>keyword arguments to adjust the fontsizes according to the gene scores</p> <code>{}</code>"},{"location":"api/#scdef.scDEF.plot_multilevel_paga","title":"<code>plot_multilevel_paga(neighbors_rep='X_factors', layers=None, figsize=(16, 4), reuse_pos=True, fontsize=12, show=True, **paga_kwargs)</code>","text":"<p>Plot a PAGA graph from each scDEF layer.</p> <p>Parameters:</p> Name Type Description Default <code>neighbors_rep</code> <code>Optional[str]</code> <p>the self.obsm key to use to compute the PAGA graphs</p> <code>'X_factors'</code> <code>layers</code> <code>Optional[list]</code> <p>which layers to plot</p> <code>None</code> <code>figsize</code> <code>Optional[tuple]</code> <p>figure size</p> <code>(16, 4)</code> <code>reuse_pos</code> <code>Optional[bool]</code> <p>whether to initialize each PAGA graph with the graph from the layer above</p> <code>True</code> <code>show</code> <code>Optional[bool]</code> <p>whether to show the plot</p> <code>True</code> <code>**paga_kwargs</code> <p>keyword arguments to adjust the PAGA layouts</p> <code>{}</code>"},{"location":"api/#scdef.scDEF.plot_obs_scores","title":"<code>plot_obs_scores(obs_keys, hierarchy=None, mode='fracs', **kwargs)</code>","text":"<p>Plot the association between a set of cell annotations and factors.</p> <p>Parameters:</p> Name Type Description Default <code>obs_keys</code> <code>Sequence[str]</code> <p>the keys in self.adata.obs to use</p> required <code>hierarchy</code> <code>Optional[dict]</code> <p>the polytree to restrict the associations to</p> <code>None</code> <code>mode</code> <code>Literal['f1', 'fracs', 'weights']</code> <p>whether to compute scores based on assignments or weights</p> <code>'fracs'</code> <code>**kwargs</code> <p>plotting keyword arguments</p> <code>{}</code>"},{"location":"api/#scdef.scDEF.plot_pathway_scores","title":"<code>plot_pathway_scores(pathways, top_genes=20, **kwargs)</code>","text":"<p>Plot the association between a set of cell annotations and a set of gene signatures.</p> <p>Parameters:</p> Name Type Description Default <code>obs_keys</code> <p>the keys in self.adata.obs to use</p> required <code>pathways</code> <code>DataFrame</code> <p>a pandas DataFrame containing PROGENy pathways</p> required <code>**kwargs</code> <p>plotting keyword arguments</p> <code>{}</code>"},{"location":"api/#scdef.scDEF.plot_signatures_scores","title":"<code>plot_signatures_scores(obs_keys, markers, top_genes=10, hierarchy=None, **kwargs)</code>","text":"<p>Plot the association between a set of cell annotations and a set of gene signatures.</p> <p>Parameters:</p> Name Type Description Default <code>obs_keys</code> <code>Sequence[str]</code> <p>the keys in self.adata.obs to use</p> required <code>markers</code> <code>Mapping[str, Sequence[str]]</code> <p>a dictionary with keys corresponding to self.adata.obs[obs_keys] and values to gene lists</p> required <code>top_genes</code> <code>Optional[int]</code> <p>number of genes to consider in the score computations</p> <code>10</code> <code>hierarchy</code> <code>Optional[dict]</code> <p>the polytree to restrict the associations to</p> <code>None</code> <code>**kwargs</code> <p>plotting keyword arguments</p> <code>{}</code>"},{"location":"api/#scdef.iscDEF","title":"<code>scdef.iscDEF</code>","text":"<p>             Bases: <code>scDEF</code></p> <p>Informed scDEF model.</p> <p>This model extends the basic scDEF by using gene sets to guide the factors. iscDEF can either set the given sets as top layer factors and learn higher-resolution structure, or use them as the lowest resolution and learn a hierarchy that relates them. All the methods from scDEF are available in iscDEF.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object containing the gene expression data. scDEF learns a model from counts, so they must be present in either adata.X or in adata.layers.</p> required <code>markers_dict</code> <code>Mapping[str, Sequence[str]]</code> <p>dictionary containing named gene lists.</p> required <code>add_other</code> <code>Optional[bool]</code> <p>whether to add factors for cells which don't express any of the sets in markers_dict.</p> <code>False</code> <code>markers_layer</code> <code>Optional[int]</code> <p>scDEF layer at which the gene sets are defined. If &gt; 0, this defines the number of layers.</p> <code>0</code> <code>n_factors_per_set</code> <code>Optional[int]</code> <p>number of lower level factors per gene set.</p> <code>3</code> <code>n_layers</code> <code>Optional[int]</code> <p>default number of scDEF layers, including a top layer of size 1 if markers_layer is 0.</p> <code>4</code> <code>cn_small_scale</code> <p>scale for low connectivity</p> required <code>cn_big_scale</code> <p>scale for large connectivity</p> required <code>cn_small_strength</code> <code>Optional[float]</code> <p>strength for weak connectivity</p> <code>100.0</code> <code>cn_big_strength</code> <code>Optional[float]</code> <p>strength for large connectivity</p> <code>1.0</code> <code>gs_small_scale</code> <code>Optional[float]</code> <p>scale for genes not in set</p> <code>0.1</code> <code>gs_big_scale</code> <code>Optional[float]</code> <p>scale for genes in set</p> <code>10.0</code> <code>marker_strength</code> <code>Optional[float]</code> <p>strength for marker genes</p> <code>100.0</code> <code>nonmarker_strength</code> <code>Optional[float]</code> <p>strength for non-marker genes</p> <code>1.0</code> <code>other_strength</code> <code>Optional[float]</code> <p>strength for marker genes of other sets</p> <code>100.0</code> <code>**kwargs</code> <p>keyword arguments for base scDEF.</p> <code>{}</code>"},{"location":"api/#benchmarking-utilities","title":"Benchmarking utilities","text":""},{"location":"api/#scdef.benchmark.run_multiple_resolutions","title":"<code>scdef.benchmark.run_multiple_resolutions(method, ad, resolution_sweep, layer_prefix='h', **kwargs)</code>","text":"<p>Run a clustering and gene signature learning method at multiple resolutions.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>the function that runs the method. Must take a resolution parameter as argument and return a list containing at least an AnnData object, a matrix containing the latent space, and a list of genes per cluster.</p> required <code>ad</code> <code>AnnData</code> <p>the data to run the method on.</p> required <code>resolution_sweep</code> <code>Sequence[float]</code> <p>list of resolution parameters to use.</p> required <p>Returns:</p> Name Type Description <code>outs</code> <code>Mapping</code> <p>dictionary containing all the outputs from the method across all resolutions. Keys: [\"latents\", \"signatures\", \"assignments\", \"scores\", \"sizes\", \"simplified_hierarchy\"]</p>"},{"location":"examples/basicusage/","title":"Basic usage","text":"<p>scDEF takes as input an AnnData object containing UMI counts. We strongly recommend filtering the data to keep only highly variable genes. With scDEF installed, start by importing the module:</p> <pre><code>import scdef\n</code></pre> <p>Then we create the <code>scDEF</code> object, passing an <code>AnnData</code> object with a layer containing the raw counts:</p> <pre><code>scd = scdef.scDEF(your_anndata_object, counts_layer='counts')\n</code></pre> <p>The <code>scDEF</code> object will hold a copy of your <code>AnnData</code> object and add annotations to it after fitting.</p> <p>And we then fit it to the data:</p> <pre><code>scd.learn()\n</code></pre> <p>After fitting, the <code>scDEF</code> object is updated with the new variational parameters and a Graphviz graph, and the <code>AnnData</code> it contains is updated with new <code>.obs</code>, <code>.obsm</code> and <code>.uns</code> fields. The graph is stored in <code>scd.graph</code> and can be generated and updated with <code>scd.make_graph</code>.</p> <p>Please see the example notebooks to learn how scDEF can be used for including hierarchical gene signature learning, clustering, and batch integration.</p>"},{"location":"examples/scdef-ifn/","title":"Identifying interferon-response between two batches of PBMCs","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\n\nimport scdef\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd import scanpy as sc  import scdef <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version &gt;=1.16.5 and &lt;1.23.0 is required for this version of SciPy (detected version 1.23.4\n  warnings.warn(f\"A NumPy version &gt;={np_minversion} and &lt;{np_maxversion}\"\n</pre> In\u00a0[2]: Copied! <pre>adata = sc.read_h5ad('pbmcs_data/ifnb/ifnb.h5ad')\nobs = pd.read_csv('pbmcs_data/ifnb/ifnb_metadata.csv', index_col=0)\nadata.obs = obs\n</pre> adata = sc.read_h5ad('pbmcs_data/ifnb/ifnb.h5ad') obs = pd.read_csv('pbmcs_data/ifnb/ifnb_metadata.csv', index_col=0) adata.obs = obs In\u00a0[3]: Copied! <pre>sc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_genes(adata, min_cells=10)\n\n# As in the paper\n# Remove MALAT1\nadata = adata[:, adata.var_names!='MALAT1']\nadata = adata[:, adata.var_names!='FTL']\nadata = adata[:, adata.var_names!='FTH1']\nadata.var['mt'] = adata.var_names.str.startswith('MTRN')  # annotate the group of mitochondrial genes as 'mt'\nsc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)\nadata = adata[adata.obs.n_genes_by_counts &lt; 5000, :]\nadata = adata[adata.obs.pct_counts_mt &lt; 5, :]\nadata.raw = adata\n\n\nraw_adata = adata.raw\nraw_adata = raw_adata.to_adata()\nraw_adata.X = raw_adata.X.toarray()\nadata.layers['counts'] =  adata.X.toarray()\n\n\n# Keep only HVGs\nsc.pp.normalize_total(adata, target_sum=1e4)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, flavor='seurat_v3', n_top_genes=4000, layer='counts', batch_key='stim') # \n\nadata = adata[:, adata.var.highly_variable]\n\n# Process and visualize the data\nsc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt'])\nsc.pp.scale(adata, max_value=10)\nsc.tl.pca(adata, svd_solver='arpack')\nsc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)\nsc.tl.umap(adata)\nsc.tl.leiden(adata)\nadata.obs['Cell types'] = adata.obs['seurat_annotations']\nadata.obs['IFN'] = adata.obs['stim']\nsc.pl.umap(adata, color=['leiden', 'Cell types', 'IFN'], ncols=3, frameon=False)\n</pre> sc.pp.filter_cells(adata, min_genes=200) sc.pp.filter_genes(adata, min_cells=10)  # As in the paper # Remove MALAT1 adata = adata[:, adata.var_names!='MALAT1'] adata = adata[:, adata.var_names!='FTL'] adata = adata[:, adata.var_names!='FTH1'] adata.var['mt'] = adata.var_names.str.startswith('MTRN')  # annotate the group of mitochondrial genes as 'mt' sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True) adata = adata[adata.obs.n_genes_by_counts &lt; 5000, :] adata = adata[adata.obs.pct_counts_mt &lt; 5, :] adata.raw = adata   raw_adata = adata.raw raw_adata = raw_adata.to_adata() raw_adata.X = raw_adata.X.toarray() adata.layers['counts'] =  adata.X.toarray()   # Keep only HVGs sc.pp.normalize_total(adata, target_sum=1e4) sc.pp.log1p(adata) sc.pp.highly_variable_genes(adata, flavor='seurat_v3', n_top_genes=4000, layer='counts', batch_key='stim') #   adata = adata[:, adata.var.highly_variable]  # Process and visualize the data sc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt']) sc.pp.scale(adata, max_value=10) sc.tl.pca(adata, svd_solver='arpack') sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40) sc.tl.umap(adata) sc.tl.leiden(adata) adata.obs['Cell types'] = adata.obs['seurat_annotations'] adata.obs['IFN'] = adata.obs['stim'] sc.pl.umap(adata, color=['leiden', 'Cell types', 'IFN'], ncols=3, frameon=False) <pre>&lt;ipython-input-3-50d85d36ccbb&gt;:9: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var['mt'] = adata.var_names.str.startswith('MTRN')  # annotate the group of mitochondrial genes as 'mt'\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/anndata/_core/anndata.py:1230: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  df[key] = c\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/anndata/_core/anndata.py:1230: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  df[key] = c\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[4]: Copied! <pre>adata\n</pre> adata Out[4]: <pre>AnnData object with n_obs \u00d7 n_vars = 13999 \u00d7 4000\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'stim', 'seurat_annotations', 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden', 'Cell types', 'IFN'\n    var: 'features', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm', 'highly_variable_nbatches', 'mean', 'std'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden', 'leiden_colors', 'Cell types_colors', 'IFN_colors'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'</pre> <p>We tell scDEF to learn per-batch gene scales by setting <code>batch_key</code>. Combined with the sparsity and non-negativity constraints in the model, this provides enough power to correct batch effects and find shared variation between the two experiments. We will see however that this correction does not remove the biological batch-specific effects of interferon stimulation.</p> In\u00a0[5]: Copied! <pre>scd = scdef.scDEF(adata, counts_layer='counts', batch_key='IFN',)\nprint(scd) # inspect the scDEF object, which contains a copy of the input AnnData\n</pre> scd = scdef.scDEF(adata, counts_layer='counts', batch_key='IFN',) print(scd) # inspect the scDEF object, which contains a copy of the input AnnData <pre>scDEF object with 5 layers\n\tLayer names: factor, hfactor, hhfactor, hhhfactor, hhhhfactor\n\tLayer sizes: 100, 60, 30, 10, 1\n\tLayer shape parameters: 0.3, 0.3, 0.3, 0.3, 1.0\n\tLayer rate parameters: 0.3, 3.0, 6.0, 10.0, 30.0\n\tLayer factor shape parameters: 1.0, 1.0, 1.0, 1.0, 1.0\n\tLayer factor rate parameters: 100.0, 1.0, 1.0, 1.0, 1.0\n\tUsing BRD with prior parameter: 1000.0\n\tNumber of batches: 2\nContains AnnData object with n_obs \u00d7 n_vars = 13999 \u00d7 4000\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'stim', 'seurat_annotations', 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden', 'Cell types', 'IFN'\n    var: 'features', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm', 'highly_variable_nbatches', 'mean', 'std'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden', 'leiden_colors', 'Cell types_colors', 'IFN_colors'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'\n</pre> In\u00a0[6]: Copied! <pre>scd.learn(n_epoch=1000) # learn the hierarchical gene signatures\n</pre> scd.learn(n_epoch=1000) # learn the hierarchical gene signatures <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [24:25&lt;00:00,  1.47s/it, Loss=1.12e+7]\n</pre> In\u00a0[7]: Copied! <pre>plt.plot(np.concatenate(scd.elbos))\nplt.yscale('log')\nplt.show()\n</pre> plt.plot(np.concatenate(scd.elbos)) plt.yscale('log') plt.show() In\u00a0[8]: Copied! <pre>scd.plot_scales(alpha=0.1)\n</pre> scd.plot_scales(alpha=0.1) In\u00a0[9]: Copied! <pre># See relevances\nscd.plot_brd(figsize=(16,4))\n</pre> # See relevances scd.plot_brd(figsize=(16,4)) In\u00a0[10]: Copied! <pre># Actually do the filtering\nscd.filter_factors(iqr_mult=1., min_cells=10)\nscd.plot_brd(figsize=(16,4))\n</pre> # Actually do the filtering scd.filter_factors(iqr_mult=1., min_cells=10) scd.plot_brd(figsize=(16,4)) In\u00a0[11]: Copied! <pre>scd.plot_gini_brd()\n</pre> scd.plot_gini_brd() In\u00a0[12]: Copied! <pre>sc.pl.umap(scd.adata, color=[f'{i}_score' for i in range(len(scd.factor_lists[0]))], frameon=False)\n</pre> sc.pl.umap(scd.adata, color=[f'{i}_score' for i in range(len(scd.factor_lists[0]))], frameon=False) In\u00a0[13]: Copied! <pre>sc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'], \n           title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False)\n</pre> sc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'],             title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[14]: Copied! <pre>scd.plot_umaps(color=['seurat_annotations', 'stim'], figsize=(16,8), fontsize=16, show=True)\n</pre> scd.plot_umaps(color=['seurat_annotations', 'stim'], figsize=(16,8), fontsize=16, show=True) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[15]: Copied! <pre>obs_keys = ['seurat_annotations', 'stim']\nscd.plot_obs_scores(obs_keys, figsize=(16,4))\n</pre> obs_keys = ['seurat_annotations', 'stim'] scd.plot_obs_scores(obs_keys, figsize=(16,4)) <p>We can visualize the relationships between the different layers using <code>scd.make_graph</code>, which uses Graphviz to plot the scDEF graph.</p> In\u00a0[16]: Copied! <pre>scd.make_graph(filled='factor', show_signatures=False) # simple graph with color-filled nodes\nscd.graph # Graphviz object\n</pre> scd.make_graph(filled='factor', show_signatures=False) # simple graph with color-filled nodes scd.graph # Graphviz object Out[16]: In\u00a0[17]: Copied! <pre>scd.make_graph(wedged='seurat_annotations', show_signatures=False) # graph with nodes filled by fraction of cells from each batch\nscd.graph # Graphviz object\n</pre> scd.make_graph(wedged='seurat_annotations', show_signatures=False) # graph with nodes filled by fraction of cells from each batch scd.graph # Graphviz object Out[17]: In\u00a0[18]: Copied! <pre>scd.make_graph(wedged='stim', show_signatures=False) # graph with nodes filled by fraction of cells from each batch\nscd.graph # Graphviz object\n</pre> scd.make_graph(wedged='stim', show_signatures=False) # graph with nodes filled by fraction of cells from each batch scd.graph # Graphviz object Out[18]: <p>This graph shows that both experiments are well represented in each factor at all levels, except for factor X which seems to be over-represented for cells in Experiment 1. Indeed, the cell type annotations indicate that Megakaryocytes only occur in Experiment 1.</p> In\u00a0[19]: Copied! <pre>scd.make_graph(show_signatures=True) # simple graph with gene signatures in nodes\nscd.graph\n</pre> scd.make_graph(show_signatures=True) # simple graph with gene signatures in nodes scd.graph Out[19]: In\u00a0[20]: Copied! <pre>hierarchy_scdef = scd.get_hierarchy()\nscd.make_graph(hierarchy=hierarchy_scdef, show_signatures=True, wedged='Cell types')\nscd.graph\n</pre> hierarchy_scdef = scd.get_hierarchy() scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=True, wedged='Cell types') scd.graph Out[20]: In\u00a0[21]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='stim', \n               n_cells=True, show_label=False, node_size_max=1.5, node_size_min=.2) # scale by number of cells and remove labels\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='stim',                 n_cells=True, show_label=False, node_size_max=1.5, node_size_min=.2) # scale by number of cells and remove labels scd.graph Out[21]: In\u00a0[22]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='seurat_annotations', \n               n_cells=True, show_label=False, node_size_max=1.5, node_size_min=.2) # scale by number of cells and remove labels\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='seurat_annotations',                 n_cells=True, show_label=False, node_size_max=1.5, node_size_min=.2) # scale by number of cells and remove labels scd.graph Out[22]: In\u00a0[23]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, top_factor='hh1', show_signatures=False, wedged='seurat_annotations', \n               n_cells_label=True, show_label=True) # scale by number of cells and remove labels\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, top_factor='hh1', show_signatures=False, wedged='seurat_annotations',                 n_cells_label=True, show_label=True) # scale by number of cells and remove labels scd.graph Out[23]: In\u00a0[24]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, top_factor='hh1', show_signatures=False, wedged='stim', \n               n_cells_label=True, show_label=True) # scale by number of cells and remove labels\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, top_factor='hh1', show_signatures=False, wedged='stim',                 n_cells_label=True, show_label=True) # scale by number of cells and remove labels scd.graph Out[24]: In\u00a0[25]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, top_factor='hh1', show_signatures=True, wedged='seurat_annotations', \n               n_cells_label=True, show_label=True) # scale by number of cells and remove labels\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, top_factor='hh1', show_signatures=True, wedged='seurat_annotations',                 n_cells_label=True, show_label=True) # scale by number of cells and remove labels scd.graph Out[25]: In\u00a0[26]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=True, wedged='stim')\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=True, wedged='stim') scd.graph Out[26]: <p>Finally, scDEF also comes with a utility function to plot associations between cell annotations and factors, using a dotplot. In this two-batch setting, this is useful to check which factors are batch-specific.</p> In\u00a0[27]: Copied! <pre># Compare with batch annotations\nscd.plot_obs_factor_dotplot('stim', 2, figsize=(16,3)) # Layer 2\nscd.plot_obs_factor_dotplot('stim', 1, figsize=(16,3)) # Layer 1\nscd.plot_obs_factor_dotplot('stim', 0, figsize=(16,3)) # Layer 0\n</pre> # Compare with batch annotations scd.plot_obs_factor_dotplot('stim', 2, figsize=(16,3)) # Layer 2 scd.plot_obs_factor_dotplot('stim', 1, figsize=(16,3)) # Layer 1 scd.plot_obs_factor_dotplot('stim', 0, figsize=(16,3)) # Layer 0 In\u00a0[28]: Copied! <pre># Compare with batch annotations\nscd.plot_obs_factor_dotplot('seurat_annotations', 2, figsize=(16,3)) # Layer 2\nscd.plot_obs_factor_dotplot('seurat_annotations', 1, figsize=(16,3)) # Layer 1\nscd.plot_obs_factor_dotplot('seurat_annotations', 0, figsize=(16,3)) # Layer 0\n</pre> # Compare with batch annotations scd.plot_obs_factor_dotplot('seurat_annotations', 2, figsize=(16,3)) # Layer 2 scd.plot_obs_factor_dotplot('seurat_annotations', 1, figsize=(16,3)) # Layer 1 scd.plot_obs_factor_dotplot('seurat_annotations', 0, figsize=(16,3)) # Layer 0"},{"location":"examples/scdef-ifn/#scdef-on-simulated-and-control-pbmcs","title":"scDEF on simulated and control PBMCs\u00b6","text":"<p>scDEF is a statistical model that learns signatures of gene expression at multiple levels of resolution in an unsupervised manner. The model enables dimensionality reduction, clustering, and de novo signature identification from scRNA-seq data.</p> <p>Here we apply scDEF to the two batches of PBMCs sequenced with 10x Genomics, one of which was stimulated with interferon, available from <code>SeuratData</code> (https://github.com/satijalab/seurat-data).</p>"},{"location":"examples/scdef-ifn/#load-packages-and-data","title":"Load packages and data\u00b6","text":""},{"location":"examples/scdef-ifn/#learn-scdef","title":"Learn scDEF\u00b6","text":""},{"location":"examples/scdef-ifn/#downstream-analyses","title":"Downstream analyses\u00b6","text":""},{"location":"examples/scdef-pbmcs-2batches/","title":"scDEF on two batches of PBMCs","text":"In\u00a0[1]: Copied! <pre>import scanpy as sc\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scdef\n</pre> import scanpy as sc import matplotlib.pyplot as plt import numpy as np import scdef <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version &gt;=1.16.5 and &lt;1.23.0 is required for this version of SciPy (detected version 1.23.4\n  warnings.warn(f\"A NumPy version &gt;={np_minversion} and &lt;{np_maxversion}\"\n</pre> In\u00a0[2]: Copied! <pre>adata = sc.read_h5ad('pbmcs_data/pbmcsca.h5ad')\n# Keep only two batches, one for each experiment, with same technology\nadata = adata[adata.obs.query(\"Method == '10x Chromium (v2) A' or Method == '10x Chromium (v2)'\").index]\n</pre> adata = sc.read_h5ad('pbmcs_data/pbmcsca.h5ad') # Keep only two batches, one for each experiment, with same technology adata = adata[adata.obs.query(\"Method == '10x Chromium (v2) A' or Method == '10x Chromium (v2)'\").index] In\u00a0[3]: Copied! <pre>adata.obs[\"Experiment\"].value_counts()\n</pre> adata.obs[\"Experiment\"].value_counts() Out[3]: <pre>pbmc2    3362\npbmc1    3222\nName: Experiment, dtype: int64</pre> In\u00a0[4]: Copied! <pre>sc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_genes(adata, min_cells=10)\n\n# As in the paper\n# Remove MALAT1\nadata = adata[:, adata.var_names != 'MALAT1']\nadata.var['mt'] = adata.var_names.str.startswith('MTRN')  # annotate the group of mitochondrial genes as 'mt'\nsc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)\nadata = adata[adata.obs.n_genes_by_counts &lt; 2000, :]\nadata = adata[adata.obs.pct_counts_mt &lt; 8, :]\n\nadata.layers['counts'] = adata.X.toarray() # Keep the counts, for scDEF\nadata.raw = adata\n\n# Keep only HVGs\nsc.pp.normalize_total(adata, target_sum=1e4)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, flavor='seurat_v3', n_top_genes=4000, layer='counts',\n                           batch_key='Experiment') # Not required, but makes scDEF faster\nadata = adata[:, adata.var.highly_variable]\n\n# Process and visualize the data\nsc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt'])\nsc.pp.scale(adata, max_value=10)\nsc.tl.pca(adata, svd_solver='arpack')\nsc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)\nsc.tl.umap(adata)\nsc.tl.leiden(adata)\nsc.pl.umap(adata, color=['leiden', 'CellType', 'Experiment'], frameon=False)\n</pre> sc.pp.filter_cells(adata, min_genes=200) sc.pp.filter_genes(adata, min_cells=10)  # As in the paper # Remove MALAT1 adata = adata[:, adata.var_names != 'MALAT1'] adata.var['mt'] = adata.var_names.str.startswith('MTRN')  # annotate the group of mitochondrial genes as 'mt' sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True) adata = adata[adata.obs.n_genes_by_counts &lt; 2000, :] adata = adata[adata.obs.pct_counts_mt &lt; 8, :]  adata.layers['counts'] = adata.X.toarray() # Keep the counts, for scDEF adata.raw = adata  # Keep only HVGs sc.pp.normalize_total(adata, target_sum=1e4) sc.pp.log1p(adata) sc.pp.highly_variable_genes(adata, flavor='seurat_v3', n_top_genes=4000, layer='counts',                            batch_key='Experiment') # Not required, but makes scDEF faster adata = adata[:, adata.var.highly_variable]  # Process and visualize the data sc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt']) sc.pp.scale(adata, max_value=10) sc.tl.pca(adata, svd_solver='arpack') sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40) sc.tl.umap(adata) sc.tl.leiden(adata) sc.pl.umap(adata, color=['leiden', 'CellType', 'Experiment'], frameon=False) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/preprocessing/_simple.py:139: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  adata.obs['n_genes'] = number\n&lt;ipython-input-4-653eb1ef138c&gt;:7: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var['mt'] = adata.var_names.str.startswith('MTRN')  # annotate the group of mitochondrial genes as 'mt'\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/anndata/_core/anndata.py:1230: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  df[key] = c\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/anndata/_core/anndata.py:1230: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  df[key] = c\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/anndata/_core/anndata.py:1230: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  df[key] = c\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/anndata/_core/anndata.py:1230: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  df[key] = c\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/anndata/_core/anndata.py:1230: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  df[key] = c\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> <p>We tell scDEF to learn per-batch gene scales by setting <code>batch_key</code>. Combined with the sparsity and non-negativity constraints in the model, this provides enough power to correct batch effects and find shared variation between the two experiments.</p> In\u00a0[5]: Copied! <pre>scd = scdef.scDEF(adata, counts_layer='counts', batch_key='Experiment',)\nprint(scd) # inspect the scDEF object, which contains a copy of the input AnnData\n</pre> scd = scdef.scDEF(adata, counts_layer='counts', batch_key='Experiment',) print(scd) # inspect the scDEF object, which contains a copy of the input AnnData <pre>scDEF object with 5 layers\n\tLayer names: factor, hfactor, hhfactor, hhhfactor, hhhhfactor\n\tLayer sizes: 100, 60, 30, 10, 1\n\tLayer shape parameters: 0.3, 0.3, 0.3, 0.3, 1.0\n\tLayer rate parameters: 0.3, 3.0, 6.0, 10.0, 30.0\n\tLayer factor shape parameters: 1.0, 1.0, 1.0, 1.0, 1.0\n\tLayer factor rate parameters: 100.0, 1.0, 1.0, 1.0, 1.0\n\tUsing BRD with prior parameter: 1000.0\n\tNumber of batches: 2\nContains AnnData object with n_obs \u00d7 n_vars = 6124 \u00d7 4000\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'nGene', 'nUMI', 'percent.mito', 'Cluster', 'CellType', 'Experiment', 'Method', 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'\n    var: 'features', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm', 'highly_variable_nbatches', 'mean', 'std'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden', 'leiden_colors', 'CellType_colors', 'Experiment_colors'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'\n</pre> <p>Fit the model to data. By default, this will run two rounds of optimization with decreasing learning rates.</p> In\u00a0[6]: Copied! <pre>scd.learn() # learn the hierarchical gene signatures\n</pre> scd.learn() # learn the hierarchical gene signatures <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [14:09&lt;00:00,  1.18it/s, Loss=4.75e+6]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [07:45&lt;00:00,  2.15it/s, Loss=4.61e+6]\n</pre> <p>Check that the ELBO converged.</p> In\u00a0[7]: Copied! <pre>plt.plot(np.concatenate(scd.elbos)[10:])\nplt.yscale('log')\nplt.show()\n</pre> plt.plot(np.concatenate(scd.elbos)[10:]) plt.yscale('log') plt.show() <p>scDEF updated the internal AnnData object with:</p> <ul> <li>Assignment of cells to factors at each layer: <code>scd.adata.obs</code></li> <li>Weight of each cell to each factor at each layer: <code>scd.adata.obs</code></li> <li>Cells by factors matrices at each layer: <code>scd.adata.obsm</code></li> <li>Gene signatures for each factor at each layer: <code>scd.adata.uns</code></li> </ul> <p>Additionally, it created a graph in Graphviz format containing the learned hierarchy: <code>scd.graph</code>.</p> In\u00a0[8]: Copied! <pre>scd.plot_scales(alpha=0.5, show=True)\n# plt.savefig('pbmcs2b_scales.pdf')\n</pre> scd.plot_scales(alpha=0.5, show=True) # plt.savefig('pbmcs2b_scales.pdf') In\u00a0[9]: Copied! <pre>scd.plot_brd(figsize=(16,4), show=True)\n# plt.savefig('pbmcs2b_brd.pdf')\n</pre> scd.plot_brd(figsize=(16,4), show=True) # plt.savefig('pbmcs2b_brd.pdf') <p>The scDEF model is constructed in such a way that the kept factors are the sparser ones. The underlying assumption is that sparse factors (where only a few genes are active) reflect biological signal, and dense factors (where many genes are active) capture technical variation. We can assess the sparsity of all the factors through their Gini index.</p> In\u00a0[10]: Copied! <pre># scd.filter_factors()\nscd.plot_gini_brd(show=True)\n# plt.savefig('pbmcs2b_ginibrd.pdf')\n</pre> # scd.filter_factors() scd.plot_gini_brd(show=True) # plt.savefig('pbmcs2b_ginibrd.pdf') In\u00a0[11]: Copied! <pre>scd.make_graph(filled='factor', show_signatures=False) # simple graph with colorful nodes\nscd.graph # Graphviz object\n</pre> scd.make_graph(filled='factor', show_signatures=False) # simple graph with colorful nodes scd.graph # Graphviz object Out[11]: <p>The scDEF hierarchy contains redudant connections, i.e., factors which capture the same cell population across different layers. We can merge these to obtain a more compact representation of the hierarchy.</p> In\u00a0[12]: Copied! <pre>hierarchy_scdef = scd.get_hierarchy()\nscd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, filled='factor')\nscd.graph\n</pre> hierarchy_scdef = scd.get_hierarchy() scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, filled='factor') scd.graph Out[12]: <p>We can also color each node by the proportion of attached cells from each batch. This helps us visualize the batch integration qualitatively.</p> In\u00a0[13]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='Experiment', \n               n_cells_label=True) # show number of cells in each node\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='Experiment',                 n_cells_label=True) # show number of cells in each node scd.graph Out[13]: <p>Or we can remove the labels and scale the node sizes by the number of cells attached to the corresponding factors.</p> In\u00a0[14]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='Experiment', \n               n_cells=True, show_label=False) # scale by number of cells and remove labels\nscd.graph\n# scd.graph.render('pbmcs2b_hrcscalenodes_experiment.pdf')\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='Experiment',                 n_cells=True, show_label=False) # scale by number of cells and remove labels scd.graph # scd.graph.render('pbmcs2b_hrcscalenodes_experiment.pdf') Out[14]: In\u00a0[15]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='CellType', \n               n_cells=True, show_label=False) # scale by number of cells and remove labels\nscd.graph\n# scd.graph.render('pbmcs2b_hrcscalenodes_celltype.pdf')\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='CellType',                 n_cells=True, show_label=False) # scale by number of cells and remove labels scd.graph # scd.graph.render('pbmcs2b_hrcscalenodes_celltype.pdf') Out[15]: <p>And we can directly visualize the gene expression signatures associated with each factor in the hierarchy.</p> In\u00a0[16]: Copied! <pre>scd.make_graph(hierarchy=scd.get_hierarchy())\nscd.graph\n</pre> scd.make_graph(hierarchy=scd.get_hierarchy()) scd.graph Out[16]: In\u00a0[17]: Copied! <pre>sc.pl.umap(scd.adata, color=[f'{i}_score' for i in range(len(scd.factor_lists[0]))], frameon=False)\n</pre> sc.pl.umap(scd.adata, color=[f'{i}_score' for i in range(len(scd.factor_lists[0]))], frameon=False) In\u00a0[18]: Copied! <pre>scd.filter_factors(filter_up=True)\nsc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'], \n       title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False)\n</pre> scd.filter_factors(filter_up=True) sc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'],         title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[19]: Copied! <pre>scd.plot_umaps(color=['CellType', 'Experiment'], figsize=(16,8), fontsize=16, show=True)\n# plt.savefig('pbmcs2b_umaps.pdf', bbox_inches='tight')\n</pre> scd.plot_umaps(color=['CellType', 'Experiment'], figsize=(16,8), fontsize=16, show=True) # plt.savefig('pbmcs2b_umaps.pdf', bbox_inches='tight') <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[20]: Copied! <pre>obs_keys = ['CellType', 'Experiment']\nscd.plot_obs_scores(obs_keys, figsize=(16,4), show=True)\n# plt.savefig('pbmcs2b_obskeys.pdf', bbox_inches='tight')\n</pre> obs_keys = ['CellType', 'Experiment'] scd.plot_obs_scores(obs_keys, figsize=(16,4), show=True) # plt.savefig('pbmcs2b_obskeys.pdf', bbox_inches='tight') <p>If we take a step further and label the factors by the annotations that they most strongly associate with, we can further validate the hierarchy.</p> In\u00a0[21]: Copied! <pre># Assign factors in simplified hierarchy to annotations\nassignments, matches = scd.assign_obs_to_factors(['CellType'], \n                        factor_names=scdef.utils.hierarchy_utils.get_nodes_from_hierarchy(hierarchy_scdef))\n\nscd.make_graph(hierarchy=hierarchy_scdef, factor_annotations=matches)\nscd.graph\n</pre> # Assign factors in simplified hierarchy to annotations assignments, matches = scd.assign_obs_to_factors(['CellType'],                          factor_names=scdef.utils.hierarchy_utils.get_nodes_from_hierarchy(hierarchy_scdef))  scd.make_graph(hierarchy=hierarchy_scdef, factor_annotations=matches) scd.graph Out[21]:"},{"location":"examples/scdef-pbmcs-2batches/#scdef-on-two-batches-of-pbmcs","title":"scDEF on two batches of PBMCs\u00b6","text":"<p>scDEF is a statistical model that learns signatures of gene expression at multiple levels of resolution in an unsupervised manner. The model enables dimensionality reduction, clustering, and de novo signature identification from scRNA-seq data.</p> <p>Here we apply scDEF to the two batches of PBMCs sequenced with Drop-seq from the Broad Institute PBMC Systematic Comparative Analysis study, available from <code>SeuratData</code> (https://github.com/satijalab/seurat-data).</p>"},{"location":"examples/scdef-pbmcs-2batches/#load-packages-and-data","title":"Load packages and data\u00b6","text":""},{"location":"examples/scdef-pbmcs-2batches/#learn-scdef","title":"Learn scDEF\u00b6","text":""},{"location":"examples/scdef-pbmcs-2batches/#inspect-size-factors","title":"Inspect size factors\u00b6","text":"<p>scDEF is able to learn gene signatures that are not confounded by library sizes and gene detection rates because it explicitely models cell and gene scale factors. To make sure these are not captured in the factors, it's a good idea to confirm that the model successfully captured these biases.</p>"},{"location":"examples/scdef-pbmcs-2batches/#inspect-automatic-model-pruning","title":"Inspect automatic model pruning\u00b6","text":"<p>By default, scDEF learns 100 factors at the highest resolution level (i.e., the lowest layer, layer 0). It also learns relevance estimates for each one, which leads to automatic model pruning. By default, after inference scDEF additionally only keeps the factors to which at least 10 cells attach and that have a relevance higher than 5 times the IQR of all the BRDs. This can be changed with <code>scd.filter_factors</code>.</p> <p>The <code>scd.plot_brd</code> utility function shows the relevancies learned for the factors.</p>"},{"location":"examples/scdef-pbmcs-2batches/#downstream-analyses","title":"Downstream analyses\u00b6","text":""},{"location":"examples/scdef-pbmcs-2batches/#visualize-scdef-graph","title":"Visualize scDEF graph\u00b6","text":"<p>We can visualize the learned scDEF using <code>scd.make_graph</code>, which uses Graphviz to plot the scDEF graph.</p>"},{"location":"examples/scdef-pbmcs-2batches/#visualize-cell-to-factor-weights","title":"Visualize cell to factor weights\u00b6","text":"<p>Each cell assigns a weight to a factor. The factors at the lowest level tend to capture different cell populations at high resolution which are aggregated in the upper levels. We can easily visualize the weights (or scores) of the factors at the lowest level in the original UMAP.</p>"},{"location":"examples/scdef-pbmcs-2batches/#visualize-cell-to-factor-assignments","title":"Visualize cell to factor assignments\u00b6","text":"<p>scDEF assigns each cell to each factor at each level of resolution. We can visualize these assignments in the original UMAP.</p>"},{"location":"examples/scdef-pbmcs-2batches/#umap-visualization-of-scdef-layers","title":"UMAP visualization of scDEF layers\u00b6","text":"<p>We can use the factors at each layer of the learned scDEF as embeddings of the cells in lower-dimensional spaces, and visualize them in 2D using, for example, a UMAP. We will color them using both the provided cell type annotations and the batch of origin.</p>"},{"location":"examples/scdef-pbmcs-2batches/#association-of-factors-with-annotations","title":"Association of factors with annotations\u00b6","text":"<p>By attaching cells to the factors that they assign most of their weight to, and comparing those assignments with the ground truth annotations, we can check which factors associate most strongly with which annotations.</p>"},{"location":"examples/scdef-pbmcs3k/","title":"scDEF on 3k PBMCs","text":"In\u00a0[1]: Copied! <pre>markers = {'Memory CD4 T': ['IL7R', 'CD3D', 'CD3E'], 'Naive CD4 T': ['IL7R', 'CCR7', 'CD3D', 'CD3E'],  'CD8 T': ['CD8B', 'CCL5', 'CD2', 'CD3D', 'CD3E'], \n           'NK': ['GNLY', 'NKG7'], \n           'B': ['MS4A1', 'CD79A'], \n           'CD14+ Mono': ['CD14', 'LYZ'],  'FCGR3A+ Mono': ['FCGR3A', 'MS4A7'],  'DC': ['FCER1A', 'CST3', 'CD74'], \n           'Platelet': ['PPBP', 'PF4']}\n\ntrue_hierarchy = {'T': ['CD8 T', 'Memory CD4 T', 'Naive CD4 T'], \n                  'Mono': ['FCGR3A+ Mono', 'CD14+ Mono'], \n                  'Platelet': [], \n                  'B': [],\n                  'CD8 T': [],\n                  'Memory CD4 T': [],\n                  'Naive CD4 T': [],\n                  'NK': [],\n                  'FCGR3A+ Mono': [],\n                  'CD14+ Mono': [],\n                  'DC': []}\n</pre> markers = {'Memory CD4 T': ['IL7R', 'CD3D', 'CD3E'], 'Naive CD4 T': ['IL7R', 'CCR7', 'CD3D', 'CD3E'],  'CD8 T': ['CD8B', 'CCL5', 'CD2', 'CD3D', 'CD3E'],             'NK': ['GNLY', 'NKG7'],             'B': ['MS4A1', 'CD79A'],             'CD14+ Mono': ['CD14', 'LYZ'],  'FCGR3A+ Mono': ['FCGR3A', 'MS4A7'],  'DC': ['FCER1A', 'CST3', 'CD74'],             'Platelet': ['PPBP', 'PF4']}  true_hierarchy = {'T': ['CD8 T', 'Memory CD4 T', 'Naive CD4 T'],                    'Mono': ['FCGR3A+ Mono', 'CD14+ Mono'],                    'Platelet': [],                    'B': [],                   'CD8 T': [],                   'Memory CD4 T': [],                   'Naive CD4 T': [],                   'NK': [],                   'FCGR3A+ Mono': [],                   'CD14+ Mono': [],                   'DC': []} In\u00a0[2]: Copied! <pre>import scanpy as sc\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport scdef\n</pre> import scanpy as sc import pandas as pd import matplotlib.pyplot as plt import numpy as np  import scdef <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version &gt;=1.16.5 and &lt;1.23.0 is required for this version of SciPy (detected version 1.23.4\n  warnings.warn(f\"A NumPy version &gt;={np_minversion} and &lt;{np_maxversion}\"\n</pre> <p>We apply the usual basic filtering for cells and genes with very low numbers of reads. While scDEF does not require further prior gene selection, it is useful to remove genes which are known to be noisy in scRNA-seq data sets, such as MALAT1. We also apply liberal highly variable gene filtering to make sure we include all possible marker genes while reducing the runtime required to fit the model.</p> In\u00a0[3]: Copied! <pre>adata = sc.read_10x_mtx(\n    'pbmcs_data/pbmcs3k/data/filtered_gene_bc_matrices/hg19/',  # the directory with the `.mtx` file\n    var_names='gene_symbols',                # use gene symbols for the variable names (variables-axis index)\n    cache=True)\nadata.obs.index = adata.obs.index.str.replace('-1', '')\n\n# Remove MALAT1\nadata = adata[:,adata.var_names!='MALAT1']\nsc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_genes(adata, min_cells=3)\nadata.var['mt'] = adata.var_names.str.startswith('MT-')  # annotate the group of mitochondrial genes as 'mt'\nsc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)\nadata = adata[adata.obs.n_genes_by_counts &lt; 2500, :]\nadata = adata[adata.obs.pct_counts_mt &lt; 5, :]\n\nadata.layers['counts'] = adata.X.toarray() # Keep the counts, for scDEF\nadata.raw = adata\n\n# Keep only HVGs\nsc.pp.normalize_total(adata, target_sum=1e4)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, flavor='seurat_v3', layer='counts', n_top_genes=4000) # Not required, but makes scDEF faster\nadata = adata[:, adata.var.highly_variable]\n\n# Process and visualize the data\nsc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt'])\nsc.pp.scale(adata, max_value=10)\nsc.tl.pca(adata, svd_solver='arpack')\nsc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)\nsc.tl.umap(adata)\nsc.tl.leiden(adata)\nsc.pl.umap(adata, color=['leiden'])\n</pre> adata = sc.read_10x_mtx(     'pbmcs_data/pbmcs3k/data/filtered_gene_bc_matrices/hg19/',  # the directory with the `.mtx` file     var_names='gene_symbols',                # use gene symbols for the variable names (variables-axis index)     cache=True) adata.obs.index = adata.obs.index.str.replace('-1', '')  # Remove MALAT1 adata = adata[:,adata.var_names!='MALAT1'] sc.pp.filter_cells(adata, min_genes=200) sc.pp.filter_genes(adata, min_cells=3) adata.var['mt'] = adata.var_names.str.startswith('MT-')  # annotate the group of mitochondrial genes as 'mt' sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True) adata = adata[adata.obs.n_genes_by_counts &lt; 2500, :] adata = adata[adata.obs.pct_counts_mt &lt; 5, :]  adata.layers['counts'] = adata.X.toarray() # Keep the counts, for scDEF adata.raw = adata  # Keep only HVGs sc.pp.normalize_total(adata, target_sum=1e4) sc.pp.log1p(adata) sc.pp.highly_variable_genes(adata, flavor='seurat_v3', layer='counts', n_top_genes=4000) # Not required, but makes scDEF faster adata = adata[:, adata.var.highly_variable]  # Process and visualize the data sc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt']) sc.pp.scale(adata, max_value=10) sc.tl.pca(adata, svd_solver='arpack') sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40) sc.tl.umap(adata) sc.tl.leiden(adata) sc.pl.umap(adata, color=['leiden']) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/preprocessing/_simple.py:139: ImplicitModificationWarning: Trying to modify attribute `.obs` of view, initializing view as actual.\n  adata.obs['n_genes'] = number\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> <p>Let's add the cell type annotations obtained from Seurat on this data set and add use it to create coarser cell type annotations. This will be useful to evaluate the scDEF hierarchy.</p> In\u00a0[4]: Copied! <pre>annotations = pd.read_csv('pbmcs_data/pbmcs3k/annotations.csv', index_col=0)\n\nmap_coarse = {}\nfor c in annotations['seurat_annotations'].astype(\"category\").cat.categories:\n    if c.endswith(' T'):\n        map_coarse[c] = 'T'\n    elif c.endswith('Mono'):\n        map_coarse[c] = 'Mono'\n    else:\n        map_coarse[c] = c\n        \nadata.obs['Cell types'] = annotations['seurat_annotations']\n\nadata.obs['Coarse cell types'] = (\n    adata.obs['Cell types']\n    .map(map_coarse)\n    .astype('category')\n)\n</pre> annotations = pd.read_csv('pbmcs_data/pbmcs3k/annotations.csv', index_col=0)  map_coarse = {} for c in annotations['seurat_annotations'].astype(\"category\").cat.categories:     if c.endswith(' T'):         map_coarse[c] = 'T'     elif c.endswith('Mono'):         map_coarse[c] = 'Mono'     else:         map_coarse[c] = c          adata.obs['Cell types'] = annotations['seurat_annotations']  adata.obs['Coarse cell types'] = (     adata.obs['Cell types']     .map(map_coarse)     .astype('category') ) In\u00a0[5]: Copied! <pre># Look at the data\nsc.pl.umap(adata, color=['Coarse cell types', 'Cell types'])\n</pre> # Look at the data sc.pl.umap(adata, color=['Coarse cell types', 'Cell types']) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> <p>We start by creating an scDEF object from the AnnData object containing the gene expression counts. scDEF requires raw counts, so we tell it to get them in the <code>counts</code> layer that we created in the pre-processing step. The model is initialized with 5 layers of sizes 100, 60, 30, 10, and 1. Due to the sparsity priors in the factor weights, most of these will be removed in the learned model, which will yield a compact representation of the hierarchical structure of the data.</p> In\u00a0[6]: Copied! <pre>scd = scdef.scDEF(adata, counts_layer='counts',)\nprint(scd) # inspect the scDEF object, which contains a copy of the input AnnData\n</pre> scd = scdef.scDEF(adata, counts_layer='counts',) print(scd) # inspect the scDEF object, which contains a copy of the input AnnData <pre>scDEF object with 5 layers\n\tLayer names: factor, hfactor, hhfactor, hhhfactor, hhhhfactor\n\tLayer sizes: 100, 60, 30, 10, 1\n\tLayer shape parameters: 0.3, 0.3, 0.3, 0.3, 1.0\n\tLayer rate parameters: 0.3, 3.0, 6.0, 10.0, 30.0\n\tLayer factor shape parameters: 1.0, 1.0, 1.0, 1.0, 1.0\n\tLayer factor rate parameters: 100.0, 1.0, 1.0, 1.0, 1.0\n\tUsing BRD with prior parameter: 1000.0\n\tNumber of batches: 1\nContains AnnData object with n_obs \u00d7 n_vars = 2623 \u00d7 4000\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden', 'Cell types', 'Coarse cell types'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm', 'mean', 'std'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden', 'leiden_colors', 'Coarse cell types_colors', 'Cell types_colors'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'\n</pre> <p>Fit the model to data. By default, this will run two rounds of optimization with decreasing learning rates.</p> In\u00a0[7]: Copied! <pre>scd.learn() # learn the hierarchical gene signatures\n</pre> scd.learn() # learn the hierarchical gene signatures <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [09:24&lt;00:00,  1.77it/s, Loss=3.13e+6]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [03:41&lt;00:00,  4.51it/s, Loss=2.98e+6]\n</pre> <p>scDEF updated the internal AnnData object with:</p> <ul> <li>Assignment of cells to factors at each layer: <code>scd.adata.obs</code></li> <li>Weight of each cell to each factor at each layer: <code>scd.adata.obs</code></li> <li>Cells by factors matrices at each layer: <code>scd.adata.obsm</code></li> <li>Gene signatures for each factor at each layer: <code>scd.adata.uns</code></li> </ul> <p>Additionally, it created a graph in Graphviz format containing the learned hierarchy: <code>scd.graph</code>.</p> <p>Let's inspect the updated object to confirm the presence of the new annotations in the internal <code>AnnData</code> object.</p> In\u00a0[8]: Copied! <pre>print(scd) # inspect the updated scDEF object\n</pre> print(scd) # inspect the updated scDEF object <pre>scDEF object with 5 layers\n\tLayer names: factor, hfactor, hhfactor, hhhfactor, hhhhfactor\n\tLayer sizes: 11, 5, 3, 1, 1\n\tLayer shape parameters: 0.3, 0.3, 0.3, 0.3, 1.0\n\tLayer rate parameters: 0.3, 3.0, 6.0, 10.0, 30.0\n\tLayer factor shape parameters: 1.0, 1.0, 1.0, 1.0, 1.0\n\tLayer factor rate parameters: 100.0, 1.0, 1.0, 1.0, 1.0\n\tUsing BRD with prior parameter: 1000.0\n\tNumber of batches: 1\nContains AnnData object with n_obs \u00d7 n_vars = 2623 \u00d7 4000\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden', 'Cell types', 'Coarse cell types', 'cell_scale', 'factor', '0_score', '1_score', '2_score', '3_score', '4_score', '5_score', '6_score', '7_score', '8_score', '9_score', '10_score', 'hfactor', 'h0_score', 'h1_score', 'h2_score', 'h3_score', 'h4_score', 'hhfactor', 'hh0_score', 'hh1_score', 'hh2_score', 'hhhfactor', 'hhh0_score', 'hhhhfactor', 'hhhh0_score'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm', 'mean', 'std', 'gene_scale'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden', 'leiden_colors', 'Coarse cell types_colors', 'Cell types_colors', 'factor_colors', 'factor_signatures', 'hfactor_colors', 'hfactor_signatures', 'hhfactor_colors', 'hhfactor_signatures', 'hhhfactor_colors', 'hhhfactor_signatures', 'hhhhfactor_colors', 'hhhhfactor_signatures'\n    obsm: 'X_pca', 'X_umap', 'X_factors', 'X_hfactors', 'X_hhfactors', 'X_hhhfactors', 'X_hhhhfactors'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'\n</pre> <p>Check that the ELBO converged.</p> In\u00a0[9]: Copied! <pre>plt.plot(np.concatenate(scd.elbos)[:])\nplt.yscale('log')\nplt.show()\n</pre> plt.plot(np.concatenate(scd.elbos)[:]) plt.yscale('log') plt.show() In\u00a0[10]: Copied! <pre>scd.plot_scales()\n</pre> scd.plot_scales() In\u00a0[11]: Copied! <pre>scd.plot_brd(figsize=(14,4))\n</pre> scd.plot_brd(figsize=(14,4)) <p>The scDEF model is constructed in such a way that the kept factors are the sparser ones. The underlying assumption is that sparse factors (where only a few genes are active) reflect biological signal, and dense factors (where many genes are active) capture technical variation. We can assess the sparsity of all the factors through their Gini index.</p> In\u00a0[12]: Copied! <pre>scd.plot_gini_brd()\n</pre> scd.plot_gini_brd() In\u00a0[13]: Copied! <pre>scd.make_graph(filled='factor', show_signatures=False) # simple graph with colorful nodes\nscd.graph # Graphviz object\n</pre> scd.make_graph(filled='factor', show_signatures=False) # simple graph with colorful nodes scd.graph # Graphviz object Out[13]: <p>The scDEF hierarchy contains redudant connections, i.e., factors which capture the same cell population across different layers. We can merge these to obtain a more compact representation of the hierarchy.</p> In\u00a0[14]: Copied! <pre>hierarchy_scdef = scd.get_hierarchy()\n\nscd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, filled='factor')\nscd.graph\n</pre> hierarchy_scdef = scd.get_hierarchy()  scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, filled='factor') scd.graph Out[14]: <p>And we can directly visualize the gene expression signatures associated with each factor in the hierarchy. We also set <code>n_cells=True</code> to show the number of cells that attach to each factor.</p> In\u00a0[15]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, n_cells_label=True)\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, n_cells_label=True) scd.graph Out[15]: <p>We can also scale the node sizes by the fraction of cells that attach to the corresponding factor by setting <code>n_cells=True</code>.</p> In\u00a0[16]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, \n               n_cells=True, # scale nodes by fraction of attached cells\n               filled='factor', # color the nodes\n               show_label=False, # remove labels to make the visualization neater\n            ) \nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef,                 n_cells=True, # scale nodes by fraction of attached cells                filled='factor', # color the nodes                show_label=False, # remove labels to make the visualization neater             )  scd.graph Out[16]: In\u00a0[17]: Copied! <pre>sc.pl.umap(scd.adata, color=[f'{i}_score' for i in range(len(scd.factor_lists[0]))], frameon=False)\n</pre> sc.pl.umap(scd.adata, color=[f'{i}_score' for i in range(len(scd.factor_lists[0]))], frameon=False) In\u00a0[18]: Copied! <pre>sc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'], \n           title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False)\n</pre> sc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'],             title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[19]: Copied! <pre>scd.plot_umaps(color=['Cell types'], fontsize=16, legend_fontsize=14)\n</pre> scd.plot_umaps(color=['Cell types'], fontsize=16, legend_fontsize=14) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[20]: Copied! <pre>obs_keys = ['Cell types', 'Coarse cell types']\nscd.plot_obs_scores(obs_keys, hierarchy=true_hierarchy, figsize=(16,4))\n</pre> obs_keys = ['Cell types', 'Coarse cell types'] scd.plot_obs_scores(obs_keys, hierarchy=true_hierarchy, figsize=(16,4)) <p>Another way to check the association of factors with the provided annotations is to color each node in the graph with the fraction of cells in it that belong to each given cell type. To do this, we set <code>wedged='celltypes'</code> in <code>scd.make_graph</code>. We normalize the fractions by the total size of each cell type.</p> In\u00a0[21]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, \n               n_cells=True, # scale nodes by fraction of attached cells\n               wedged='Cell types', # color the nodes\n               show_label=False, # remove labels to make the visualization neater\n            ) \nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef,                 n_cells=True, # scale nodes by fraction of attached cells                wedged='Cell types', # color the nodes                show_label=False, # remove labels to make the visualization neater             )  scd.graph Out[21]: <p>If we take a step further and label the factors by the annotations that they most strongly associate with, we can further validate the hierarchy.</p> In\u00a0[22]: Copied! <pre># Assign factors in simplified hierarchy to annotations\nassignments, matches = scd.assign_obs_to_factors(obs_keys,\n                            factor_names=scdef.utils.hierarchy_utils.get_nodes_from_hierarchy(hierarchy_scdef))\n\n# Show graph with new labels \nscd.make_graph(hierarchy=hierarchy_scdef, factor_annotations=matches)\nscd.graph\n</pre> # Assign factors in simplified hierarchy to annotations assignments, matches = scd.assign_obs_to_factors(obs_keys,                             factor_names=scdef.utils.hierarchy_utils.get_nodes_from_hierarchy(hierarchy_scdef))  # Show graph with new labels  scd.make_graph(hierarchy=hierarchy_scdef, factor_annotations=matches) scd.graph Out[22]: <p>With these assignments, we can select a particular lineage to plot. Additionally, here we also show the gene signature confidences by setting <code>show_confidences=True</code>.</p> In\u00a0[23]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, top_factor=assignments['T'], factor_annotations=matches, \n               show_confidences=True, mc_samples=10)\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, top_factor=assignments['T'], factor_annotations=matches,                 show_confidences=True, mc_samples=10) scd.graph Out[23]: In\u00a0[24]: Copied! <pre>scd.make_graph(hierarchy=hierarchy_scdef, top_factor=assignments['Mono'], factor_annotations=matches, \n               show_confidences=True, mc_samples=10)\nscd.graph\n</pre> scd.make_graph(hierarchy=hierarchy_scdef, top_factor=assignments['Mono'], factor_annotations=matches,                 show_confidences=True, mc_samples=10) scd.graph Out[24]: In\u00a0[25]: Copied! <pre>sc.pl.rank_genes_groups(scd.adata, n_genes=25, sharey=False, key=\"factor_signatures\")\n</pre> sc.pl.rank_genes_groups(scd.adata, n_genes=25, sharey=False, key=\"factor_signatures\") <p>Because we have a list of marker genes for each cell type in the data, we can check the association of the learned gene signatures with each cell type's markers.</p> In\u00a0[26]: Copied! <pre>scd.plot_signatures_scores(\"Cell types\", markers, top_genes=25, figsize=(16,4))\n</pre> scd.plot_signatures_scores(\"Cell types\", markers, top_genes=25, figsize=(16,4)) In\u00a0[27]: Copied! <pre>scd.plot_multilevel_paga(figsize=(16,4), reuse_pos=True, frameon=False)\n</pre> scd.plot_multilevel_paga(figsize=(16,4), reuse_pos=True, frameon=False) In\u00a0[28]: Copied! <pre>iscd = scdef.iscDEF(adata, counts_layer='counts', markers_dict=markers,)\n\nprint(iscd) # inspect the iscDEF object, which contains a copy of the input AnnData\n</pre> iscd = scdef.iscDEF(adata, counts_layer='counts', markers_dict=markers,)  print(iscd) # inspect the iscDEF object, which contains a copy of the input AnnData <pre>Did not find gene CCR7 for set Naive CD4 T in AnnData object.\n</pre> <pre>iscDEF object with 5 layers\n\tMarkers layer: 0\n\tContains `other` category: False\n\tGene set strength: 100.0\n\tGene set mean: 10.0\n\tLayer names: markerfactor, hfactor, hhfactor, hhhfactor, hhhhfactor\n\tLayer sizes: 9, 6, 3, 2, 1\n\tLayer shape parameters: 0.3, 0.3, 0.3, 0.3, 1.0\n\tLayer rate parameters: 0.3, 3.0, 6.0, 9.0, 30.0\n\tLayer factor shape parameters: 1.0, 1.0, 1.0, 1.0, 1.0\n\tLayer factor rate parameters: 1.0, 1.0, 1.0, 1.0, 1.0\n\tNumber of batches: 1\nContains AnnData object with n_obs \u00d7 n_vars = 2623 \u00d7 4000\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden', 'Cell types', 'Coarse cell types'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm', 'mean', 'std'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden', 'leiden_colors', 'Coarse cell types_colors', 'Cell types_colors'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'\n</pre> In\u00a0[29]: Copied! <pre>iscd.learn() # learn the hierarchical gene signatures\n</pre> iscd.learn() # learn the hierarchical gene signatures <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [02:09&lt;00:00,  7.73it/s, Loss=3e+6]   \n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [01:25&lt;00:00, 11.67it/s, Loss=2.88e+6]\n</pre> In\u00a0[30]: Copied! <pre>iscd.plot_scales()\n</pre> iscd.plot_scales() In\u00a0[31]: Copied! <pre>iscd.make_graph(show_signatures=False, filled='factor')\niscd.graph\n</pre> iscd.make_graph(show_signatures=False, filled='factor') iscd.graph Out[31]: In\u00a0[32]: Copied! <pre>hrc = iscd.get_hierarchy()\niscd.make_graph(hierarchy=hrc, show_signatures=True, filled='factor')\niscd.graph\n</pre> hrc = iscd.get_hierarchy() iscd.make_graph(hierarchy=hrc, show_signatures=True, filled='factor') iscd.graph Out[32]: In\u00a0[33]: Copied! <pre>iscd.make_graph(hierarchy=hrc, show_signatures=False, filled='factor', show_label=False, n_cells=True)\niscd.graph\n</pre> iscd.make_graph(hierarchy=hrc, show_signatures=False, filled='factor', show_label=False, n_cells=True) iscd.graph Out[33]: In\u00a0[34]: Copied! <pre>iscd.make_graph(hierarchy=hrc, show_signatures=False, wedged='Cell types', show_label=False, n_cells=True)\niscd.graph\n</pre> iscd.make_graph(hierarchy=hrc, show_signatures=False, wedged='Cell types', show_label=False, n_cells=True) iscd.graph Out[34]: In\u00a0[35]: Copied! <pre>iscd.make_graph(hierarchy=hrc, show_signatures=False, wedged='Cell types', show_label=True, n_cells=False)\niscd.graph\n</pre> iscd.make_graph(hierarchy=hrc, show_signatures=False, wedged='Cell types', show_label=True, n_cells=False) iscd.graph Out[35]: In\u00a0[36]: Copied! <pre>sc.pl.umap(iscd.adata, color=['markerfactor', 'hfactor', 'hhfactor', 'hhhfactor'], \n           title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], \n           frameon=False)\n</pre> sc.pl.umap(iscd.adata, color=['markerfactor', 'hfactor', 'hhfactor', 'hhhfactor'],             title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'],             frameon=False) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[37]: Copied! <pre>obs_keys = ['Cell types', 'Coarse cell types']\niscd.plot_obs_scores(obs_keys, hierarchy=true_hierarchy, figsize=(16,4))\n</pre> obs_keys = ['Cell types', 'Coarse cell types'] iscd.plot_obs_scores(obs_keys, hierarchy=true_hierarchy, figsize=(16,4)) In\u00a0[38]: Copied! <pre>top_markers = {'T': ['CD3D', 'CD3E', 'CD8B', 'CD2', 'IL7R', 'NKG7'],\n               'Mono': ['LYZ', 'CST3', 'MS4A7'],\n               'B': ['MS4A1', 'CD79A']}\n\niscd = scdef.iscDEF(adata, counts_layer='counts', markers_dict=top_markers, markers_layer=3)\nprint(iscd) # inspect the iscDEF object, which contains a copy of the input AnnData\n</pre> top_markers = {'T': ['CD3D', 'CD3E', 'CD8B', 'CD2', 'IL7R', 'NKG7'],                'Mono': ['LYZ', 'CST3', 'MS4A7'],                'B': ['MS4A1', 'CD79A']}  iscd = scdef.iscDEF(adata, counts_layer='counts', markers_dict=top_markers, markers_layer=3) print(iscd) # inspect the iscDEF object, which contains a copy of the input AnnData <pre>iscDEF object with 4 layers\n\tMarkers layer: 3\n\tContains `other` category: False\n\tGene set strength: 100.0\n\tGene set mean: 10.0\n\tLayer names: factor, hfactor, hhfactor, markerfactor\n\tLayer sizes: 27, 18, 9, 3\n\tLayer shape parameters: 0.3, 0.3, 0.3, 0.3\n\tLayer rate parameters: 0.3, 0.9, 1.8, 2.7\n\tConnectivity mean: 10.0\n\tNumber of batches: 1\nContains AnnData object with n_obs \u00d7 n_vars = 2623 \u00d7 4000\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden', 'Cell types', 'Coarse cell types'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm', 'mean', 'std'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden', 'leiden_colors', 'Coarse cell types_colors', 'Cell types_colors'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'\n</pre> In\u00a0[39]: Copied! <pre>iscd.learn() # learn the hierarchical gene signatures\n</pre> iscd.learn() # learn the hierarchical gene signatures <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [02:43&lt;00:00,  6.10it/s, Loss=3.08e+6]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [02:00&lt;00:00,  8.27it/s, Loss=2.95e+6]\n</pre> In\u00a0[40]: Copied! <pre>iscd.plot_scales()\n</pre> iscd.plot_scales() In\u00a0[41]: Copied! <pre>iscd.plot_brd(iqr_mult=1.)\n</pre> iscd.plot_brd(iqr_mult=1.) In\u00a0[42]: Copied! <pre>iscd.filter_factors(iqr_mult=1.)\n</pre> iscd.filter_factors(iqr_mult=1.) In\u00a0[43]: Copied! <pre>iscd.plot_gini_brd()\n</pre> iscd.plot_gini_brd() In\u00a0[44]: Copied! <pre>iscd.make_graph(show_signatures=False, filled='factor')\niscd.graph\n</pre> iscd.make_graph(show_signatures=False, filled='factor') iscd.graph Out[44]: In\u00a0[45]: Copied! <pre>hrc = iscd.get_hierarchy()\niscd.make_graph(hrc, show_signatures=True, filled='factor')\niscd.graph\n</pre> hrc = iscd.get_hierarchy() iscd.make_graph(hrc, show_signatures=True, filled='factor') iscd.graph Out[45]: In\u00a0[46]: Copied! <pre>iscd.make_graph(hierarchy=hrc, show_signatures=False, filled='factor', show_label=False, n_cells=True)\niscd.graph\n</pre> iscd.make_graph(hierarchy=hrc, show_signatures=False, filled='factor', show_label=False, n_cells=True) iscd.graph Out[46]: In\u00a0[47]: Copied! <pre>iscd.make_graph(hierarchy=hrc, show_signatures=False, wedged='Cell types', show_label=False, n_cells=True)\niscd.graph\n</pre> iscd.make_graph(hierarchy=hrc, show_signatures=False, wedged='Cell types', show_label=False, n_cells=True) iscd.graph Out[47]: In\u00a0[48]: Copied! <pre>sc.pl.umap(iscd.adata, color=['factor', 'hfactor', 'hhfactor', 'markerfactor'], \n           title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False)\n</pre> sc.pl.umap(iscd.adata, color=['factor', 'hfactor', 'hhfactor', 'markerfactor'],             title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[49]: Copied! <pre>obs_keys = ['Cell types', 'Coarse cell types']\niscd.plot_obs_scores(obs_keys, hierarchy=true_hierarchy, figsize=(16,4), sort_layer_factors=False)\n</pre> obs_keys = ['Cell types', 'Coarse cell types'] iscd.plot_obs_scores(obs_keys, hierarchy=true_hierarchy, figsize=(16,4), sort_layer_factors=False)"},{"location":"examples/scdef-pbmcs3k/#scdef-on-3k-pbmcs","title":"scDEF on 3k PBMCs\u00b6","text":"<p>scDEF is a statistical model that learns signatures of gene expression at multiple levels of resolution. The model enables dimensionality reduction, clustering, and de novo signature identification from scRNA-seq data. scDEF can be run in a fully unsupervised manner, or be guided by known gene sets, which we denote informed scDEF (iscDEF).</p> <p>Here we apply scDEF in its unsupervised and informed versions to the 3k PBMCs data set from 10x Genomics used in the <code>scanpy</code> tutorial, using annotations obtained from <code>Seurat</code>.</p>"},{"location":"examples/scdef-pbmcs3k/#create-a-ground-truth","title":"Create a ground truth\u00b6","text":"<p>We will use known markers and the true hierarchical structure for the cell types in this data set to evaluate the performance of scDEF.</p>"},{"location":"examples/scdef-pbmcs3k/#load-packages-and-data","title":"Load packages and data\u00b6","text":""},{"location":"examples/scdef-pbmcs3k/#scdef","title":"scDEF\u00b6","text":"<p>The basic scDEF learns a multilayer representation of scRNA-seq data without any prior information.</p>"},{"location":"examples/scdef-pbmcs3k/#learn-scdef","title":"Learn scDEF\u00b6","text":""},{"location":"examples/scdef-pbmcs3k/#inspect-size-factors","title":"Inspect size factors\u00b6","text":"<p>scDEF is able to learn gene signatures that are not confounded by library sizes and gene detection rates because it explicitely models cell and gene scale factors. To make sure these are not captured in the factors, it's a good idea to confirm that the model successfully captured these biases.</p>"},{"location":"examples/scdef-pbmcs3k/#inspect-automatic-model-pruning","title":"Inspect automatic model pruning\u00b6","text":"<p>By default, scDEF learns 100 factors at the highest resolution level (i.e., the lowest layer, layer 0). It also learns relevance estimates for each one, which leads to automatic model pruning. By default, after inference scDEF additionally only keeps the factors to which at least 10 cells attach and that have a relevance higher than 5 times the IQR of all the BRDs. This can be changed with <code>scd.filter_factors</code>.</p> <p>The <code>scd.plot_brd</code> utility function shows the relevancies learned for the factors.</p>"},{"location":"examples/scdef-pbmcs3k/#downstream-analyses","title":"Downstream analyses\u00b6","text":"<p>scDEF produces a hierarchy of factors containing gene signatures for cell states at multiple levels of resolution. We can visualize the hierarchy as a graph, inspect its gene signatures, assign cells to factors, project each layer to 2D, and check associations between the factors and user-provided cell annotations.</p>"},{"location":"examples/scdef-pbmcs3k/#visualize-scdef-graph","title":"Visualize scDEF graph\u00b6","text":"<p>We can visualize the learned scDEF using <code>scd.make_graph</code>, which uses Graphviz to plot the scDEF graph.</p>"},{"location":"examples/scdef-pbmcs3k/#visualize-cell-to-factor-weights","title":"Visualize cell to factor weights\u00b6","text":"<p>Each cell assigns a weight to a factor. The factors at the lowest level tend to capture different cell populations at high resolution which are aggregated in the upper levels. We can easily visualize the weights (or scores) of the factors at the lowest level in the original UMAP.</p>"},{"location":"examples/scdef-pbmcs3k/#visualize-cell-to-factor-assignments","title":"Visualize cell to factor assignments\u00b6","text":"<p>Based on the cell-to-factor weights, scDEF assigns each cell to each factor at each level of resolution. We can visualize these assignments in the original UMAP.</p>"},{"location":"examples/scdef-pbmcs3k/#umap-visualization-of-scdef-layers","title":"UMAP visualization of scDEF layers\u00b6","text":"<p>We can use the factors at each layer of the learned scDEF as embeddings of the cells in lower-dimensional spaces, and visualize them in 2D using, for example, a UMAP.</p>"},{"location":"examples/scdef-pbmcs3k/#association-of-factors-with-annotations","title":"Association of factors with annotations\u00b6","text":"<p>By attaching cells to the factors that they assign most of their weight to, and comparing those assignments with the ground truth annotations, we can check which factors associate most strongly with which annotations.</p>"},{"location":"examples/scdef-pbmcs3k/#gene-signatures","title":"Gene signatures\u00b6","text":"<p>scDEF provides gene signatures for each factor in each layer in <code>scd.adata.uns</code>, which allows for interaction with <code>scanpy</code>'s plotting utilities.</p>"},{"location":"examples/scdef-pbmcs3k/#visualize-paga-graphs-at-the-different-scdef-layers","title":"Visualize PAGA graphs at the different scDEF layers\u00b6","text":"<p>We can also visualize the multilayer structure of scDEF in a PAGA graph. This will show a graph representing the similarity between the factors at each layer. We can leverage the structure of the scDEF by initializing the graph at each layer <code>i</code> with the graph at layer <code>i+1</code> to keep them consistent across layers.</p>"},{"location":"examples/scdef-pbmcs3k/#informed-scdef","title":"Informed scDEF\u00b6","text":"<p>The informed version of scDEF enables the joint assignment of cells to known states given by a dictionary of marker genes, and learning either a lower or higher-resolution description of the data using those states.</p> <p>Given a list of marker genes for different cell groups, iscDEF can jointly assign cells to those groups and either 1) learn an upper level structure relating the groups or 2) learn a lower level structure containing higher resolution groups of cells within the specified ones.</p>"},{"location":"examples/scdef-pbmcs3k/#mode-1-learning-a-higher-level-structure-from-cell-subtypes","title":"Mode 1: learning a higher level structure from cell subtypes\u00b6","text":"<p>By default, iscDEF will learn put the gene sets as factors in the lowest layer in the hierarchy, which is set to 4 layers, but can be changed with the <code>n_layers</code> keyword argument. The factors at the lowest layer will be named after the names in the dictionary that contains the gene sets. In this mode, the BRD prior is deactivated.</p>"},{"location":"examples/scdef-pbmcs3k/#mode-2-learning-a-lower-level-structure-from-coarse-cell-types","title":"Mode 2: learning a lower level structure from coarse cell types\u00b6","text":"<p>If we set markers_layer to a value above 0, iscDEF will put the gene sets in the top level of the hierarchy, whose depth is set to be <code>markers_layer-1</code>. Here we set <code>markers_layer</code> to 3, which will lead to a 4-level hierarchy (layers are 0-indexed). At each subsequent level, iscDEF will have by default 2 factors per gene-set specific factors. This can be changed with the <code>n_factors_per_set</code> keyword argument. This mode will thus be guided by broad gene sets that get refined at each level of the hierarchy. Here we use sets containing markers for T, B and monocytic cells, and learn cell states that correspond to T-, B- and monocyte-specific subpopulations. The BRD prior is by default activated in this mode, and can be used to remove unused factors as in the base scDEF.</p>"},{"location":"examples/scdef-planaria/","title":"Cell type hierarchies in a whole adult animal","text":"In\u00a0[1]: Copied! <pre>true_hierarchy = {'stem cells': ['neoblast'], \n                  'neurons': ['ChAT neurons 1', 'ChAT neurons 2', 'GABA neurons',  'spp-11+ neurons', 'npp-18+ neurons', 'cav-1+ neurons', 'neural progenitors'], \n                  'epidermis': ['early epidermal progenitors', 'activated early epidermal progenitors', 'epidermal neoblasts', 'epidermis', 'epidermis DVb', 'epidermis DVb neoblast', 'late epidermal progenitors 1', 'late epidermal progenitors 2'], \n                  'muscle': [ 'muscle body', 'muscle pharynx', 'muscle progenitors', ],\n                  'parenchyma': ['pgrn+ parenchymal cells', 'ldlrr-1+ parenchymal cells', 'psap+ parenchymal cells', 'aqp+ parenchymal cells', 'parenchymal progenitors',],\n                  'secretory': [ 'secretory 1', 'secretory 2', 'secretory 3', 'secretory 4'],\n                  'pharynx': ['pharynx cell type progenitors', 'pharynx cell type', ],\n                  'gut': ['gut progenitors','phagocytes', 'goblet cells',],\n                  'protonephridia': ['protonephridia'],\n                  'pigment': ['pigment'],\n                  'otf+ cells 1': ['otf+ cells 1'],\n                  'otf+ cells 2': ['otf+ cells 2'],\n                  'psd+ cells': ['psd+ cells'],\n                  'glia': ['glia']}\n</pre> true_hierarchy = {'stem cells': ['neoblast'],                    'neurons': ['ChAT neurons 1', 'ChAT neurons 2', 'GABA neurons',  'spp-11+ neurons', 'npp-18+ neurons', 'cav-1+ neurons', 'neural progenitors'],                    'epidermis': ['early epidermal progenitors', 'activated early epidermal progenitors', 'epidermal neoblasts', 'epidermis', 'epidermis DVb', 'epidermis DVb neoblast', 'late epidermal progenitors 1', 'late epidermal progenitors 2'],                    'muscle': [ 'muscle body', 'muscle pharynx', 'muscle progenitors', ],                   'parenchyma': ['pgrn+ parenchymal cells', 'ldlrr-1+ parenchymal cells', 'psap+ parenchymal cells', 'aqp+ parenchymal cells', 'parenchymal progenitors',],                   'secretory': [ 'secretory 1', 'secretory 2', 'secretory 3', 'secretory 4'],                   'pharynx': ['pharynx cell type progenitors', 'pharynx cell type', ],                   'gut': ['gut progenitors','phagocytes', 'goblet cells',],                   'protonephridia': ['protonephridia'],                   'pigment': ['pigment'],                   'otf+ cells 1': ['otf+ cells 1'],                   'otf+ cells 2': ['otf+ cells 2'],                   'psd+ cells': ['psd+ cells'],                   'glia': ['glia']} In\u00a0[2]: Copied! <pre># import warnings\n# warnings.filterwarnings('ignore')\n\n# import os\n# os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' \n\n# import jax.numpy as jnp\n\nimport numpy as np\n# import pandas as pd\nimport matplotlib.pyplot as plt\nimport scanpy as sc\n\nimport scdef\n</pre> # import warnings # warnings.filterwarnings('ignore')  # import os # os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'   # import jax.numpy as jnp  import numpy as np # import pandas as pd import matplotlib.pyplot as plt import scanpy as sc  import scdef <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version &gt;=1.16.5 and &lt;1.23.0 is required for this version of SciPy (detected version 1.23.4\n  warnings.warn(f\"A NumPy version &gt;={np_minversion} and &lt;{np_maxversion}\"\n</pre> In\u00a0[3]: Copied! <pre>adata = sc.read_h5ad('planaria/planaria_pp.h5ad')\n</pre> adata = sc.read_h5ad('planaria/planaria_pp.h5ad')  In\u00a0[4]: Copied! <pre>adata.obs['clusters_coarse'].value_counts()\n</pre> adata.obs['clusters_coarse'].value_counts() Out[4]: <pre>stem cells        8075\nepidermis         4391\nneurons           2358\nmuscle            2351\nparenchyma        2042\ngut                745\nsecretory          466\npigment            321\npharynx            292\npsd+ cells         174\notf+ cells 1       166\notf+ cells 2       127\nprotonephridia      80\nglia                24\nName: clusters_coarse, dtype: int64</pre> In\u00a0[5]: Copied! <pre>ax = sc.pl.umap(adata, color=['clusters_neoblasts'], frameon=False, show=False)\nax.set_title('')\nplt.show()\n</pre> ax = sc.pl.umap(adata, color=['clusters_neoblasts'], frameon=False, show=False) ax.set_title('') plt.show() <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[6]: Copied! <pre>adata\n</pre> adata Out[6]: <pre>AnnData object with n_obs \u00d7 n_vars = 21612 \u00d7 4900\n    obs: 'n_genes', 'n_counts', 'louvain', 'clusters', 'clusters_neoblasts', 'clusters_coarse'\n    var: 'n_cells', 'mean', 'std'\n    uns: 'clusters_coarse_colors', 'clusters_colors', 'clusters_neoblasts_colors', 'clusters_neoblasts_sizes', 'clusters_sizes', 'log1p', 'louvain', 'louvain_colors', 'neighbors', 'paga', 'pca', 'tsne', 'umap'\n    obsm: 'X_pca', 'X_tsne', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'connectivities', 'distances'</pre> In\u00a0[7]: Copied! <pre>scd = scdef.scDEF(adata, counts_layer='counts',)\nprint(scd) # inspect the scDEF object, which contains a copy of the input AnnData\n</pre> scd = scdef.scDEF(adata, counts_layer='counts',) print(scd) # inspect the scDEF object, which contains a copy of the input AnnData <pre>scDEF object with 5 layers\n\tLayer names: factor, hfactor, hhfactor, hhhfactor, hhhhfactor\n\tLayer sizes: 100, 60, 30, 10, 1\n\tLayer shape parameters: 0.3, 0.3, 0.3, 0.3, 1.0\n\tLayer rate parameters: 0.3, 3.0, 6.0, 10.0, 30.0\n\tLayer factor shape parameters: 1.0, 1.0, 1.0, 1.0, 1.0\n\tLayer factor rate parameters: 100.0, 1.0, 1.0, 1.0, 1.0\n\tUsing BRD with prior parameter: 1000.0\n\tNumber of batches: 1\nContains AnnData object with n_obs \u00d7 n_vars = 21612 \u00d7 4900\n    obs: 'n_genes', 'n_counts', 'louvain', 'clusters', 'clusters_neoblasts', 'clusters_coarse'\n    var: 'n_cells', 'mean', 'std'\n    uns: 'clusters_coarse_colors', 'clusters_colors', 'clusters_neoblasts_colors', 'clusters_neoblasts_sizes', 'clusters_sizes', 'log1p', 'louvain', 'louvain_colors', 'neighbors', 'paga', 'pca', 'tsne', 'umap'\n    obsm: 'X_pca', 'X_tsne', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'connectivities', 'distances'\n</pre> <p>Large datasets may not fit in GPU memory. In these cases scDEF can be learned with a small <code>batch_size</code>. We will also use fewer epochs to make learning quicker. We can then check the ELBO trace to assess convergence.</p> In\u00a0[8]: Copied! <pre>scd.learn(n_epoch=[1000], lr=0.1) # learn the hierarchical gene signatures\n</pre> scd.learn(n_epoch=[1000], lr=0.1) # learn the hierarchical gene signatures <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [28:06&lt;00:00,  1.69s/it, Loss=5.89e+7]\n</pre> In\u00a0[9]: Copied! <pre>plt.plot(np.concatenate(scd.elbos)[100:])\nplt.yscale('log')\nplt.show()\n</pre> plt.plot(np.concatenate(scd.elbos)[100:]) plt.yscale('log') plt.show() In\u00a0[10]: Copied! <pre>scd.plot_scales()\n</pre> scd.plot_scales() In\u00a0[11]: Copied! <pre># See relevances\nscd.plot_brd(iqr_mult=4, figsize=(16,4))\n</pre> # See relevances scd.plot_brd(iqr_mult=4, figsize=(16,4)) In\u00a0[12]: Copied! <pre># Actually do the filtering\nscd.filter_factors(iqr_mult=2.)\n</pre> # Actually do the filtering scd.filter_factors(iqr_mult=2.)  In\u00a0[13]: Copied! <pre>sc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'], \n           title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False)\n</pre> sc.pl.umap(scd.adata, color=['factor', 'hfactor', 'hhfactor', 'hhhfactor'],             title=['Layer 0', 'Layer 1', 'Layer 2', 'Layer 3'], frameon=False) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> <p>As indicated in the log messages, the <code>scd.adata</code> object was updated with multiple annotations based on the filtered factors. For example, it assigned each cell to each factor at each level of resolution. We can visualize these assignments in the original UMAP.</p> <p>We can visualize the relationships between the different layers using <code>scd.make_graph</code>, which uses Graphviz to plot the scDEF graph.</p> In\u00a0[14]: Copied! <pre>scd.make_graph(filled='factor', show_signatures=False) # simple graph with color-filled nodes\nscd.graph # Graphviz object\n</pre> scd.make_graph(filled='factor', show_signatures=False) # simple graph with color-filled nodes scd.graph # Graphviz object Out[14]: <p>Let's color the nodes by the known cluster labels, both at coarse and high-resolution ones (respectively <code>clusters_neoblasts</code> and <code>clusters_coarse</code>).</p> In\u00a0[15]: Copied! <pre>scd.make_graph(wedged='clusters_coarse', show_signatures=False)\nscd.graph\n</pre> scd.make_graph(wedged='clusters_coarse', show_signatures=False) scd.graph Out[15]: In\u00a0[16]: Copied! <pre>scd.make_graph(wedged='clusters_neoblasts', show_signatures=False)\nscd.graph\n</pre> scd.make_graph(wedged='clusters_neoblasts', show_signatures=False) scd.graph Out[16]: In\u00a0[17]: Copied! <pre>hierarchy_scdef = scd.get_hierarchy()\nscd.make_graph(hierarchy_scdef, show_signatures=False, wedged='clusters_neoblasts',\n              color_edges=False)\nscd.graph\n</pre> hierarchy_scdef = scd.get_hierarchy() scd.make_graph(hierarchy_scdef, show_signatures=False, wedged='clusters_neoblasts',               color_edges=False) scd.graph Out[17]: In\u00a0[24]: Copied! <pre>hierarchy_scdef = scd.get_hierarchy()\nscd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='clusters_neoblasts', \n               n_cells=True, show_label=False, node_size_min=0.5, node_size_max=3.,\n              color_edges=False) # scale by number of cells and remove labels\nscd.graph\n# scd.graph.render('planaria_hrc.pdf')\n</pre> hierarchy_scdef = scd.get_hierarchy() scd.make_graph(hierarchy=hierarchy_scdef, show_signatures=False, wedged='clusters_neoblasts',                 n_cells=True, show_label=False, node_size_min=0.5, node_size_max=3.,               color_edges=False) # scale by number of cells and remove labels scd.graph # scd.graph.render('planaria_hrc.pdf') Out[24]: In\u00a0[19]: Copied! <pre>scd.plot_umaps(color=['clusters_neoblasts'])\n</pre> scd.plot_umaps(color=['clusters_neoblasts']) <pre>/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/cluster/work/bewi/members/pedrof/miniconda3/envs/py38/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:391: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</pre> In\u00a0[20]: Copied! <pre>obs_keys = ['clusters_neoblasts', 'clusters_coarse']\nscd.plot_obs_scores(obs_keys, figsize=(16,10), hierarchy=true_hierarchy)\n</pre> obs_keys = ['clusters_neoblasts', 'clusters_coarse'] scd.plot_obs_scores(obs_keys, figsize=(16,10), hierarchy=true_hierarchy) <p>The graph shows the top scoring genes for each factor at the lowest layer, and their aggregations in the upper layers. For example, factors 2 and 7 in Layer 0 correspond to respectively, and they are aggregated in Layer 1. Similarly, factors 8 and 9 in Layer 0 correspond to T cell subtypes and they are aggregated in Layer 1.</p> <p>The level of inheritance between layers can be controlled in the scDEF object parameters via <code>factor_shapes</code>. By default, these are set to <code>[1., .1, .1]</code>. To increase the level of inheritance, we can increase the Layer 1 and Layer 2 terms, for example to <code>[1., 10., 10.]</code>. The aggregations will then be stronger.</p> <p>We can also visualize the multilayer structure of scDEF in a PAGA graph. This will show a graph representing the similarity between the factors at each layer. We can leverage the structure of the scDEF by initializing the graph at each layer <code>i</code> with the graph at layer <code>i+1</code> to keep them consistent across layers.</p> In\u00a0[21]: Copied! <pre>scd.plot_multilevel_paga(figsize=(16,4), reuse_pos=True, frameon=False)\n</pre> scd.plot_multilevel_paga(figsize=(16,4), reuse_pos=True, frameon=False) <p>Finally, scDEF also comes with a utility function to plot associations between cell annotations and factors, using a dotplot. In a multi-batch setting, this is useful to check which factors are batch-specific. Here we simply compare the factors with the annotations provided by Leiden clustering, which is an <code>obs</code> in the <code>scd.adata</code> object.</p>"},{"location":"examples/scdef-planaria/#scdef-on-a-whole-adult-planaria","title":"scDEF on a whole adult Planaria\u00b6","text":"<p>scDEF is a statistical model that learns signatures of gene expression at multiple levels of resolution in an unsupervised manner. The model enables dimensionality reduction, clustering, and de novo signature identification from scRNA-seq data.</p> <p>Here we apply scDEF to the Schmidtea mediterranea data set  used in the <code>PAGA</code> paper (https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x#Fig3). We start from pre-processed data following https://nbviewer.org/github/rajewsky-lab/planarian_lineages/blob/master/paga/planaria.ipynb and https://nbviewer.org/github/theislab/paga/blob/master/planaria/planaria.ipynb.</p> <p>Muscle: mhc, myoD</p> <p>Neuronal: coe, chat</p> <p>Parenchymal: runt-2</p> <p>Gut: ferritin, cathepsinC</p> <p>Epidermal: vim-1, ifa-1 (dd_Smed_v6_364_0)</p> <p>Muscle/Neuronal: gli1, trim9</p> <p>Parenchymal/Neuronal: trim37, traf1</p> <p>Parenchymal/Gut: nfx-1</p> <p>Epidermal/Gut: traf2, creb3</p> <p>Parenchymal/Neuronal/Muscle: nova, paxilin</p> <p>Parenchymal/Neuronal/Gut: tor, bcat-3</p> <p>Neoblast: Smedwi-1, tub-\\alpha1</p>"},{"location":"examples/scdef-planaria/#ground-truth","title":"Ground truth\u00b6","text":""},{"location":"examples/scdef-planaria/#load-packages-and-data","title":"Load packages and data\u00b6","text":""},{"location":"examples/scdef-planaria/#learn-scdef","title":"Learn scDEF\u00b6","text":""},{"location":"examples/scdef-planaria/#downstream-analyses","title":"Downstream analyses\u00b6","text":""}]}